#pragma once

#include <iostream>
#include <string>
#include <utility>
#include <vector>

#include "tm_stats.h"

/// Report the result of a test.  This is templated so that we can reuse it for
/// a variety of different types of experiments that produce different result
/// value types.
///
/// For simple tests, in which we only compare the return values of functions,
/// we can call those functions in the act of producing the results parameter,
/// which leads to some very compact code :)
///
/// @param cat      The category of the test
/// @param desc     The test description
/// @param results  A vector of pairs of T, where each pair represents a result
///                 that was generated by the original and a result that was
///                 generated by the instrumented code.
/// @param stats    A vector of pairs of stat names and their expected values
///                 for this unit test
template <typename T>
bool report(const char *cat, const char *desc,
            std::vector<std::pair<T, T>> results,
            std::vector<std::pair<TM_STATS, int>> stats) {
  using std::cout;
  using std::left;
  using std::right;

  std::string l = "[";
  l += cat;
  l += "]";
  cout.width(15);
  cout << std::left << l;
  cout.width(95);
  std::string d = std::string(desc).substr(0, 95);
  cout << std::left << d;
  cout.width(10);
  cout << right;

  // Test the result values
  bool fail = false;
  for (auto i : results) {
    if (i.first != i.second) {
      if (!fail) {
        fail = true;
        cout << "[FAILED]\n";
        cout << left;
      }
      cout << "\t Mismatch {" << i.first << "} != {" << i.second << "}\n";
    }
  }
  if (fail)
    return false;
  // Make sure that all stats match expected values
  for (auto i : stats) {
    auto found = TM_STATS_GET(i.first);
    if (found != i.second) {
      if (!fail) {
        fail = true;
        cout << "[FAILED]\n";
        cout << left;
      }
      cout.width(15);
      cout << " ";
      cout << "" << TM_STAT_NAMES[i.first] << " {" << found << "} != {"
           << i.second << "}\n";
    }
  }
  if (fail)
    return false;
  cout << "[OK]\n";
  return true;
}

/// Conduct a test that expects memory to change.  This will ultimately forward
/// to the report<>() function
///
/// @param cat      The category of the test
/// @param desc     The test description
/// @param tests    A pair representing the uninstrumented and instrumented
///                 tests to run
/// @param param    The value to pass to the test functions
/// @param addr     The address that the tests are expected to modify
/// @param val      The value that /addr/ should have before each test runs
/// @param stats    A vector of pairs of stat names and their expected values
///                 for this unit test
template <typename T, typename P>
bool mem_test(const char *cat, const char *desc,
              std::pair<void (*)(P), void (*)(T)> tests, T *addr, T val,
              P param, std::vector<std::pair<TM_STATS, int>> stats) {
  // run the uninstrumented test
  *addr = val;
  tests.first(param);
  auto uninst_res = *addr;
  // run the instrumented test
  *addr = val;
  tests.second(param);
  auto inst_res = *addr;
  *addr = val;
  return report<T>(cat, desc, {{uninst_res, inst_res}}, stats);
}